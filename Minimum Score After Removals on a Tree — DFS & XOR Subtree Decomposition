from collections import defaultdict

class Solution:
    def minimumScore(self, nums, edges):
        n = len(nums)
        tree = defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)

        parent = [-1] * n
        in_time = [0] * n
        out_time = [0] * n
        subtree_xor = [0] * n
        time = [0]  # mutable integer

        def dfs(u, p):
            in_time[u] = time[0]
            time[0] += 1
            subtree_xor[u] = nums[u]
            for v in tree[u]:
                if v == p:
                    continue
                parent[v] = u
                dfs(v, u)
                subtree_xor[u] ^= subtree_xor[v]
            out_time[u] = time[0]

        dfs(0, -1)
        totalXor = subtree_xor[0]
        res = float('inf')

        # Get all edges as (child, parent) after DFS
        edges = []
        for v in range(1, n):
            edges.append((v, parent[v]))

        for i in range(len(edges)):
            a, pa = edges[i]
            for j in range(i + 1, len(edges)):
                b, pb = edges[j]

                # Case 1: a is in subtree of b
                if in_time[b] <= in_time[a] < out_time[b]:
                    xor1 = subtree_xor[a]
                    xor2 = subtree_xor[b] ^ subtree_xor[a]
                    xor3 = totalXor ^ subtree_xor[b]
                # Case 2: b is in subtree of a
                elif in_time[a] <= in_time[b] < out_time[a]:
                    xor1 = subtree_xor[b]
                    xor2 = subtree_xor[a] ^ subtree_xor[b]
                    xor3 = totalXor ^ subtree_xor[a]
                else:
                    xor1 = subtree_xor[a]
                    xor2 = subtree_xor[b]
                    xor3 = totalXor ^ subtree_xor[a] ^ subtree_xor[b]

                maxX = max(xor1, xor2, xor3)
                minX = min(xor1, xor2, xor3)
                res = min(res, maxX - minX)

        return res
